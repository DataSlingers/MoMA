% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/moma_arguments.R
\name{moma_sparsity_options}
\alias{moma_sparsity_options}
\title{Sparsity-inducing penalty in \code{MoMA}}
\arguments{
\item{...}{Force users to specify arguments by names.}

\item{lambda}{A vector containing penalty values}

\item{select_scheme}{A char being either "b" (nested BIC search) or "g" (grid search).

MoMA provides a flexible framework for regularized multivariate analysis
with several tuning parameters for different forms of regularization.
To assist the user in selecting these parameters (\code{alpha_u},
\code{alpha_v}, \code{lambda_u}, \code{lambda_v}), we provide
two selection modes: grid search ("g") and nested BIC search ("b").
Grid search means we solve the problem
for all combinations of parameter values provided by the user.

To explain nested BIC search, we need to look into how the algorithm runs.
To find an (approximate) solution to a penalized SVD (Singular Value Decomposition) problem is to solve two
penalized regression problems iteratively. Let's call them problem u and problem v, which give
improving estimates of the right singular vector, \emph{u}, and the left singular vector, \emph{v}, respectively.
For each regression problem, we can select the optimal parameters
based on BIC.

The nested BIC search is essentially two 2-D searches. We start from SVD solutions, and then find the optimal
parameters for problem u, given current estimate of \emph{v}. Using the result from previous step, update
current estimate of \emph{u}, and then do the same thing for problem v,
that is, to find the optimal parameters for problem v given current estimate of \emph{u}. Repeat
the above until convergence or the maximal number of iterations has been reached.

Users are welcome to refer to section 3.1: Selection of Regularization Parameters
in the paper cited below.}
}
\description{
In the package \code{MoMA}, we support the following sparsity-inducing
penalty functions.
\itemize{
  \item{\code{\link{moma_lasso}}}: sparsity
  \item{\code{\link{moma_mcp}}}: non-convex sparsity
  \item{\code{\link{moma_scad}}}: non-convex sparsity
  \item{\code{\link{moma_slope}}}: sparsity
  \item{\code{\link{moma_grplasso}}}: group-wise sparsity
  \item{\code{\link{moma_fusedlasso}}}: piecewise constant, or ordered fusion
  \item{\code{\link{moma_spfusedlasso}}}: sparsity and piece-wise constant
  \item{\code{\link{moma_l1tf}}}: piecewise polynomial (default to piecewise linear)
  \item{\code{\link{moma_cluster}}}: unordered fusion
}
These functions specify the value of the \code{u_sparse,v_sparse} arguments in the
 \code{moma_*pca} series of functions, and the \code{x_sparse,y_sparse} arguments
in the \code{moma_*cca} and \code{moma_*lda} series of functions.
}
\details{
All functions
above share two common parameters: \code{lambda} and \code{select_scheme}, which are
described in the Arguments section.
}
\references{
G. I. Allen and M. Weylandt, "Sparse and Functional Principal
Components Analysis," 2019 IEEE Data Science Workshop (DSW),
Minneapolis, MN, USA, 2019, pp. 11-16. \doi{10.1109/DSW.2019.8755778}.
}
